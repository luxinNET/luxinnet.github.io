---
layout: post
title: Krahets88道 双指针
category: algorithm Notes
tags: [algorithm, Python, Dual pointers]
---

## 判断子序列

> Problem: [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/description/)

# 思路

> 单词循环逐个对比各个字符串

# 解题方法

> 比较基础的双指针应用

# 复杂度

时间复杂度:
> 添加时间复杂度, 示例： O(n)

空间复杂度:
> 添加空间复杂度, 示例： O(1)

# Code

~~~Python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        """判断子序列"""
        i = j = 0
        if not s:
            return True
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
                if i == len(s):
                    return True
            j += 1
        return False
~~~

## 链表的中间节点

> Problem: [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

# 思路

> 没思路，看了提示用快慢指针，也没做出来

# 解题方法

对于链表了解的不多，一直以为双指针指的是两个索引，但不清楚的是，对于链表而言，应将指针理解为引用

# 复杂度

时间复杂度:
> 添加时间复杂度, 示例： O(n)

空间复杂度:
> 添加空间复杂度, 示例： O(n)



# Code

~~~Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
            链表的中间节点
            对于链表了解的不多，一直以为双指针指的是两个索引，但不清楚的是，对于链表而言，应将指针理解为引用
        """
        fast = slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
~~~
  

## 相交链表

> Problem: [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)

# 思路

> 没做出来，以下为Krahests的思路：

> 设HeadA到公共节点之前的长度为a，设HeadB到公共节点之前的长度为b，公共长度为c。

> 已知：a + c + b  =  b + c + a

> 即 HeadA到公共节点之前的长度 加上 公共长度 加上 HeadB到公共节点之前的长度 等于 HeadB到公共节点之前的长度 加上 HeadA到公共节点之前的长度

# 解题方法

通过同时从headA、headB开始循环，直至找到公共节点为止，如遍历完链表后仍未找到则返回空。

# 复杂度

时间复杂度:
> 添加时间复杂度, 示例： O(n)

空间复杂度:
> 添加空间复杂度, 示例： O(1)



# Code

~~~Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        A, B = headA, headB
        while a != b:
            A = A.next if A else headB
            B = B.next if B else headA
        # 很神奇，一时竟未理解这种写法为何不会导致死循环，看了评论区找到了答案：即使A和B无相交节点也会再遍历到最后时结束，因为两链表末尾都有Null节点
~~~


## 两数之和 II - 输入有序数组

> Problem: [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

# 思路、解题方法

> 已知数组按正序排列，使用双指针指向数组首尾。如果和大于目标值则将头指针向后移动来使和更大；如果和小于目标值则将尾指针向前移动来使和更小（俗称对撞双指针）。

# 复杂度

时间复杂度:
> 添加时间复杂度, 示例： O(n)

空间复杂度:
> 添加空间复杂度, 示例： O(1)



# Code

~~~Python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i, j = 0, len(numbers) -1
        if len(numbers) <= 1:
            return None
        while i < j:
            if numbers[j] + numbers[i] > target:
                j -= 1
            elif numbers[j] + numbers[i] < target:
                i += 1
            else:
                return [i + 1, j + 1]
~~~

## 环形链表 II

> Problem: [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

# 思路

> 啊！用了笨办法哈希表做出来了，看了K神的双指针讲解，又学到了。

# 解题方法

设快慢指针（似乎对于链表则都是快慢指针，跟链表的特性有关），

# 复杂度

时间复杂度:
> 添加时间复杂度, 示例： O()

空间复杂度:
> 添加空间复杂度, 示例： O()



# Code

~~~Python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        dic = dict()
        while head:
            dic[head.val] = head 
            head = head.next
            if head.val in dic.keys():
                return dic[head.val]
        return None

~~~

## 最长回文串

> Problem: [409. 最长回文串]

# 思路

> 

# 解题方法



# 复杂度

时间复杂度:
> 添加时间复杂度, 示例： O()

空间复杂度:
> 添加空间复杂度, 示例： O()



# Code

~~~Python
~~~