---
layout: post
title: 《机器学习》笔记-第2章 模型评估与选择
category: Machine Learning
tags: [Machine Learning Theory]
---

## 2.1 经验误差与过拟合

通常我们把分类错误的样本数占总数的比例称为“错误率”(error rate)，即如果在m个样本中有a个样本分类错误，则错误率为E = a/m ，相应的，1-a/m 称为“精度”(accuracy)，即“精度=1-错误率”。更一般的，我们把学习在训练集上的误差称为“训练误差”(training error)或“经验误差”(empirical error)，在新样本上的误差称为“泛化误差”(generalization error)。显然我们希望得到泛化误差小的学习器，然而，我们事先并不知道新样本是什么样，实际能做的努力使经验误差最小化。

过拟合亦称“过配”。

欠拟合亦称“欠配”

我们实际希望的，是在新样本尚能表现得很好的学习器。为了达到这个目的，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”，这样才能在遇到新样本时做出正确的判别。当学习器把训练样本学得太好了的时候，可能吧已经训练样本的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象陈伟“过拟合”(overfitting)。与过拟合相对的是“欠拟合”(underfitting)，这是指对训练样本的一般性质尚未学好。

学习能力是否强大，是由学习算法和数据内涵共同决定的。

由多种因素可以导致过拟合，最常见的情况是由于学习能力过于强大，而欠拟合则通常是由学习能力低下造成的。欠拟合比较容易克服，例如在决策树中扩展分支、在神经网络学习中扩展分支、在神经网络学习中增加训练轮数等，而过拟合是无法彻底避免的，我们所能做的只是“缓解”，或者说减小其风险。可以理解为：机器学习面临的问题通常是NP难甚至更难，而有效的学习算法必然是在多项时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获得最游戏，这意味我们构造性地证明了 P = NP；因此，只要相信P != NP，过拟合就不可避免。

现实任务中，往往有多种学习算法可供选择，甚至对同一个算法，当使用不同参数配置时，也会产生不同的模型。

## 2.2评估方法

现实任务中，往往还会考虑到时间开销、存储开销、可解释性等方面的因素，这里暂时只考虑泛化误差。

通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择。为此，需使用一个测试集(testing set)来测试学习器对新样本的判断能力，然后以测试集上的测试误差(testing error)作为泛化误差的近拟。通过我们假设测试样本也是从样本真实分布中独立同步采样而得。需注意的是，测试集应尽可能与训练集互斥，即测试样本尽量不在训练集中出现、未在训练过程中使用过。

可是我们通常只有一个包含m个样例地数据集D，既要训练又要测试，则需要对D进行适当的处理，从中产生训练集和测试集，可以用以下方法。

### 留出法

留出法(hold-out)是直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T。需要注意的是，训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响，例如在分类任务中至少要保持样本的类别比例相似。另一个需要注意的问题是，即便在给定训练/测试集的样本比例后，仍存在多种划分方式对初始数据集D进行分割。

在使用留出法时，一般要采用若干次随即划分、重复进行实验评估后取平均值作为留出法的评估结果。可从“偏差-方差”角度来理解：测试集小时，评估结果的方差较大；训练集小时，评估结果的偏差较大。一般而言，测试集至少应含30个样例。

### 交叉验证法

亦称“k倍交叉验证”

交叉验证法(cross validation)先将数据集D划分为k个大小相似的互斥子集，每个子集Di都尽可能保持数据分布的一致性，即从D中通过分层采样得到。然后，每次用k-1个自己的并集作为训练集，余下的那个自己作为测试集；这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。

与留出法相似，将数据集D划分为k个子集同样存在多种划分方式。例如常见的又“10次10折交叉验证”。

### 自助法

自助法(bootstrapping)是一个比较好的解决方案，他直接以自主采样法(bootstrap sampling)为基础给定包含m个样本的数据集D，我们对它进行采样产生数据集D':每次随即从D中挑选一个样本，将其拷贝放入D'，然后再将该样本放回初始数据集D中，使得该样本在下次采样时仍有可能被采到;这个过程重复执行m次后，我们就得到了包含m个样本的数据集D'，这就是自主采样的结果。

自助法在数据集较小、难以有效性划分训练/测试集时很有用；此外，自助法能从初始数据中产生多个不同的训练集，这对集成学习等方法有很大的好处。

### 调参与最终模型

大多数学习算法的有些参数需要设定，参数配置不同，学得模型的性能往往有显著差别。因此，在进行模型评估与选择时，除了要对使用学习算法进行选择，还需对算法参数进行设定，这就是通常所说的“参数调节”或简称“调参”(parameter tuning)。

机器学习常设计两类参数：一类是算法的参数，亦称“超参数”，数目常在10以内；另一类是模型的参数，数目可能有很多，例如大型“深度学习”模型甚至有上百亿个参数，两者调参方式相似，均是产生多个模型之后基于某种评估方法来进行选择；不同之处在于前者通常由人工设定多个参数候选值后产生模型，后者则是通过学习来产生多个候选模型（例如神经网络在不同轮数停止训练）。

## 性能度量

性能度量(performance measure)反映了任务需求，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果；这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。

在预测任务中，给定样例集D={(x1,y1), (x2,y2), ..,(xm,ym)}，其中yi就是示例xi的真实标记。要评估学习器f的性能，就要把学习器预测结果f(x)与真实标记y进行比较。

回归任务最常用的性能度量是“均方误差”(mean squared error)

错误率与精度

错误率和精度，是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。

查准率、查全率与F1

查准率亦称“准确率”，查全率亦称“召回率”。类似的需求在信息检索、Web搜索等应用中经常出现，例如在信息检索中，我们经常会关心“检索出的信息中有多少比例是用户感兴趣的”“用户感兴趣的信息中有多少倍检索出来了”。查准率(precision)与查全率(recall)是更为适用于此类需求的性能度量。

查准率与查全率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。

平衡点(Break-Even Point, 简称BEP)就是这样一个度量，它是“查准率=查全率”时的取值。但BEP过于简化了些，更常用的是F1度量。

F1是基于查准率与查全率的调和平均(harmonicmean)定义的:1/F1 = 1/2 * (1/P + 1/R)。

ROC与AUC

在不同的任务中，我们可根据任务需求来采用不同的截断点，例如我们更重视查准率，则可选择排序中靠前的位置进行截断；若更重视查全率，则可选择靠后的位置进行截断。因此，排序本身的质量好坏，体现了综合考虑学习器在不同任务下的“期望泛化性能”的好坏。ROC曲线则是从这个角度出发来研究学习器泛化性能的有力工具。

ROC全称是“受试者工作特征”(Receiver Operating Characterisitc)曲线。与PR曲线类似，根据学习器的预测结果对样例进行排序，按此顺序逐个把样本作为正例进行预测，每次计算出两个重要的值，根据他们为横纵坐标作图，得到ROC曲线。

若一个学习器的ROC曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者，若两个学习器的ROC曲线发生交叉，则难以一般地断言两者孰优孰劣。此时如要进行比较，则较为合理的判断依据是比较ROC曲线下的面积，即AUC(Area UnderROC Curve)。形式化地看，AUC考虑的是样本预测的排序质量，因此它与排序误差有紧密联系。

代价敏感错误率与代价曲线

为权衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价”(unequal cost)。一般情况下，重要的是代价比值而非绝对值。

## 比较检验

统计假设检验(hypothesis test)为我们进行学习器性能比较提供了重要依据。

假设检验

假设检验中的“假设”是对学习器泛化错误率分布的某种判断和猜想。现实任务中我们并不知道学习器的泛化错误率，只能获知其测试错误率^E泛化错误率与测试错误率未必相同，但直观上，二者接近的可能性应比较大，相差很远的可能性比较小。因此，可根据测试错误率估推出泛化错误率的分布。
