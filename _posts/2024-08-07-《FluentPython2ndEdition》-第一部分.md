---
layout: post
title: 《FluentPython2ndEdition》-第一部分
category: Read Notes
tags: [FluentPython2ndEdition, Pythonic]
comments: true
---

## 第一章 Python数据模型

* 通过特殊方法利用Python数据模型，这样做有两个优点
  * 类的用户不需要记住标准操作的方法名称。
  * 可以充分利用Python标准库，例如random.choice函数，无需重复发明轮子。

### 特殊方法是如何使用的？

要明确一点，特殊方法供Python解释器调用，而不是你自己。也就是说，没有 my_object.__len__()这种写法，正确的写法是len(my_object)。

特殊方法的重要用途：

#### 模拟数值类型

__abs__获取对象的绝对值

__mul__、__add__返回一个新的Vector实例，没有修改运算对象，只读取self或other。

#### 对象的字符串表示形式

__repr__获取对象的字符串表现形式。

Vector类__repr__方法中的f字符串使用!r以标准的表示形式显示属性。

于此形成对照的是__str__方法由内置函数str()调用，在背后供print()函数使用，返回对终端用户友好的字符串。

如果你熟悉的边程序语言使用ToString()方法，你可能习惯实现__str__方法，而不是__repr__方法。在Python中如果必须二选一的话，请选择__repr__方法。

#### 对象的布尔值

默认情况下，用户定义类的实例都是真值，除非实现了__bool__或__len__方法。

#### 容器API

每一个容器类型均应实现如下事项

* Iterable要支持for、拆包和其他迭代方式
* Sized要支持内置函数len
* Container要支持in运算符
  
Python不强制要求具体类继承这些抽象基类中的任何一个。这要实现了__len__方法，就说明那个类满足Sized接口。

Collection有3个非常重要的专用接口

* Sequence规范和list和str等内置类型的接口
* Mappingi被dict、collections.defaultdict等实现
* Set是set和frozenset两个内置类型的接口

### len为什么不是方法

因为经过了特殊的处理，被当作Python数据模型的一部分，就像abs函数一样。但是借助特殊方法__len__，也可以让len适用于自定义对象。这是一种相对公平的折中方案，既满足了对内置对象速度的要求，又保证了语言的一致性。

延伸阅读  [Python语言参考手册](https://docs.python.org/zh-cn/3/reference/index.html)

## 第二章 丰富的序列

>> 深入理解Python中不同的序列类型，不但能避免重新发明轮子，还可以从他们共通的接口上受到启发，在自己实现API时合理支持及利用现有和将来可能添加的序列类型。

### 内置序列概览

#### 容器序列

可存放不同类型的项，其中包括嵌套容器。例如 list、tuple 和 collections.deque。

存放的是对象的引用，对象可以是任意类型。

#### 扁平序列

可存放一种简单类型的项，例如 str、bytes 和 array.array。

在自己的内存空间中存储所含内容的值，而不是各自不同的Python对象。

### 列表推导式和生成器表达式

使用列表推导式（目标是了列表）或生成器表达式（目标是其他序列类型）可以快速构建一个序列。

使用这两种句法写出的代码更容易理解，速度通常更快。

列表推导式涵盖map和filter两个函数的功能。

生成器一次产出一项提供给for循环，如果是两个各有1000项的列表，则使用生成器表达式计算笛卡尔积可以节省大量内存，因为不用先构建一个包含100万项的列表提供给for循环。

### 元组不仅仅是不可变列表

元祖有两个作用，除了可以作为不可变列表外，还可用作没有字段名称的记录。

>> 一般使用_表是虚拟变量

Python解释器和标准库经常把元祖当做不可变列表使用，这样做意图清晰（只要在源码中见到元组，你就知道它长度不可变），性能优越。

元祖的不可变性仅针对元祖中的引用而言。元祖中的引用不可删除，不可替换。倘若引用的时可变对象，改动对象之后，元祖的值也会随之变化。存放可变项的元组可能会导致bug。

### 序列和可迭代对象拆包

拆包的特点是不用我们自己动手通过索引从序列中提取元素，这样就减少了出错的可能。

拆包的目标可以是任意可迭代对象。

定义函数时可以使用*args捕获余下的任意数量的参数，这是Python的一个经典特性。

### 序列模式匹配

match关键字后面的表达式是 __匹配对象__ ，即各个case字句中尝试匹配的数据。

case _ 是默认的case语句，相当于C#中的default。

表面上看，match/case与C语言中的switch/case语法很相似。与swith相比，match的一大改进时支持 __析构__，这是一种高级拆包形式。

在match/case上下文中，str、bytes和bytearray实例不作为序列处理。match把这些类型视为原子值，就像证书987被视为一个整体值，而不是数字序列。

与拆包不同，模式不析构序列意外的可迭代对象。

添加类型信息可以让模式更加具体。

以if开头的卫语句是可选的，仅当匹配模式时才运行。

模式匹配是一种声明式编程风格，即描述你想匹配什么，而不是如何匹配，这样写出的代码结构与数据结构是一致的。

 18.3节还会进一步分析lis.py，届时将全面研究evaluate中的match/case语句，如果想要深入了解lis.py，可阅读Norvig写的文章：​“[(How to Write a (Lisp)Interpreter (in Python))](https://norvig.com/lispy.html) ”​。

### 切片

本节讨论切片的高级用法。

#### 为什么切片和区间排除最后一项

切片和区间排除最后一项是一种Python风格约定，有以下好处

* 在仅指定停止位置时，容易判断切片或区间的长度。
* 同时指定起始和停止位置时，容易计算切片或区间的长度，做个减法即可：stop - start。

arr = [10,20,30,40,50,60]  
arr[:2] 代表从开始位置到索引2截止，排除最后一项
arr[2:] 代表从索引2开始到最后位置截止，包含最后一项

还可以使用arr[a:b:c]句法来制定步距c，让切片跳过部分项。步距也可以是负数，反向返回项。

a:b:c表示法只在[]内部有效，表是索引或下标索引。

#### 多维切片和省略号

例如，在外部包numPy中，numpy.ndarray表示的二维数组可以使用a[i,j]句法获取数组中的元素，还可以使用表达式a[m:n, k:l]获取二维切片。

NumPy在处理多位数组切片时把...解释为一种快捷句法。例如，对四位数组x x[i, ...]是x[i, :, :, :]的快捷句法。

#### 为切片赋值

在赋值语句的左侧使用切片表示法，或者作为del语句的目标，可以就地移植、切除或以其他方式修改可变序列。

如果赋值目标是一个切片，则右边必须是一个可迭代对象，即便只有一项。

### 使用 + 和 * 处理序列

+和 * 始终创建一个新对象，绝不更改操作数

初始化潜逃列表可以使用 * 运算符，例如 board = [['_'] * 3 for i in range(3)]

对不可变序列重复拼接效率低下，因为解释器必须复制整个目标序列，创建一个新序列，包含要拼接的项，而不是简单追加新项

不要在元组中存放可变的项

增量赋值不是原子操作。

检查Python字节码不太难，从中可以看出Python在背后做了什么。

### list.sort与内置函数sorted

list.sort方法就地排序列表，即不创建副本，返回值为None，目的就是提醒我们，它更改了接收者，没有创建新列表。这是PythonAPI的一个重要约定：__就地更改对象的函数或方法应该返回None，让调用方清楚地知道接收者已被更改，没有创建新对象__

与之相反，内置函数sorted返回创建的新列表。该函数接收任何可迭代对象作为参数，包括不可变序列生成器。无论传入什么类型的可迭代对象，sorted函数始终反悔新创建的列表。

顺便说一下，使用key参数，哪怕掺杂数值和类似数值的字符串，也可以排序。我们只需要决定把所有项全都视为整数还是字符串。

### 当列表不适用时

#### array

使用数组处理上百万个浮点数可以节省大量内存。数组支持所有可变序列操作，此外还有快速加载项和保存项的方法。

从Python3.10开始，array类型没有列表那种就低排序方法sort，如果需要排序，请使用内置函数sorted重构数组。原因可能是数组是存储在连续的空间内，使用sort方法原地排序性能开销较大。

#### memoryview

内置的memoryview类型是一种共享内存的序列类型，可在不复制字节的情况下处理数组的切片。

memoryview是NumPy中一种普遍使用的结构，本质上就是Python中的数组。memoryview在数据结构(例如PIL图像、SQLite数据库、NumPy数组等)之间共享内存，而不是事先复制，这对大型数据集来说非常重要。

如果要对数组做一些高级数值处理，应该使用NumPy库。

#### NumPy

科学计算需要经常做一些高级数组和矩阵运算，得益于NumPy,Python成为这一领域的主流语言。NumPy实现了多维同构数组和矩阵类型，除了存放数值外，还可以存放用户定义的记录，而且提高了高效的元素层面操作。

NumPy和SciPy这两个库功能异常强大，为很多优秀的工具提供了坚实的基础，例如Pandas和scikit-learn。

#### 双端队列和其他队列

列表可以当做栈或队列使用，但是插入和删除项有一定开销，因为整个列表都必须在内存中移动。

collections.deque类实现一种线程安全的双端队列，旨在快速在两端插入和删除项。

除了deque外，Python标准库中的其他包还实现了以下队列

* queue
* multiprocessing
* asyncio
* heapq

## 第三章 字典和集合

Python中的字典能如此高效，要归功于 __哈希表__。

除了字典外，内置类型中的set和frozenset也基于哈希表。

### 字典的现代用法

__字典推导式__ 从任何可迭代对象中获取键值对，构建dict实例。

调用函数时，不止一个参数可以使用**。但是，所有键都要是字符串，而且在所有参数中是唯一的。

**可以在dict字面量中使用，同样可以多次使用。这种情况下允许键重复，后面的键覆盖前面的键。

#### 使用|合并映射

Python3.9支持|和|=操作符合并映射。因为两者也是并集运算符。

使用|运算符创建一个新映射，通常新映射的类型与左操作数的类型相同。

如果想就地更新因故射，则使用|=运算符。

### 使用模式匹配处理映射

不同类型的模式可以组合和嵌套，不同类型的模式可以组合和嵌套。借助析构可以处理嵌套和序列等结构化记录。我们经常需要从Json API和具有半结构化的数据库中读取这类记录。

模式中键的顺序无关紧要。

倘若你想把多出的键值对捕获到一个dict中，可以在一个变量前面加上**，不过必须放在模式最后。

### 映射类型的标准API

#### 可哈希指的是什么？

如果一个对象的哈希玛在整个生命周期内永不改变（依托__hash__方法），而且可与其他对象比较（依托__eq__方法），那么这个对象就是可哈希的。两个哈希对象仅当哈希玛相同时相等。

数值类型和不可变的扁平类型str和bytes都是可哈希的。

一个对象的哈希玛根据所用的Python版本和设备架构有所不同。正确实现的对象，其哈希玛在一个Python进程内保持不变。

#### 插入或更新可变的值

根据Python的快速失败原则，当键k不存在时，d[k]抛出错误，如果需要默认值，可以把d[k]换成d.get(k, default)。这样写并不完美，最好使用d.setdefault(key,[]).append(value)。

### 自动处理缺失的键

人为设置默认值有两种办法：第一种是把普通的dict换成defaultdict，第二种是定义dict或其他映射类型的子类，实现__missing__方法。

#### defaultdict：处理缺失键的另一种选择

实现的原理是，实例化defaultdict对象时提供一个可调用对象，当__getitem__遇到不存在的键时，调用那个可调用对象生成一个默认值。

举个例子，假设使用 dd = defaultdict(list)创建一个defaultdict对象，而且dd中没有"new-key"键，那么dd["new-key"]表达式按以下几步处理。

* 调用list()创建一个新列表
* 把该列表插入dd，对应到'new-key'键上。
* 返回该列表的引用。

#### __missing__方法

映射处理缺失键的底层逻辑在__missing__方法中。dict基类本身没有定义这个方法，但如果dict的子类定义了这个方法，那么dict.__getitem__找不到键时将调用__mingssing__方法，不抛出KeyError。

自己定义的类，如果继承标准库中的映射，在实现__getitem__、get或__contains__方法时不一定要回落到__missing__方法，因为标准库对missing__方法的使用不一致。

dict子类只实现__mingssing方法，其他均不实现。

collections.UserDict子类，同样实现__missing__方法，其他均不实现。继承自UserDict的get方法调用__getitem。在查找键时可能会调用missing方法。

abc.Maaping子类，以最简单的方式实现__getitem__方法

abc.Mapping子类，实现__getitem__方法，并定义__missing__方法。

### dict的变体

#### collections.OrderedDict

自Python3.6起，内置的dict也保留键的顺序，使用OrderedDict的主要原因是编写与早期Python版本兼容的代码。

#### collections.ChainMap

ChainMap实例存放一组映射，可作为一个整体来搜索。此实例不复制输入映射，而是存放映射的引用。

#### collections.Counter

这是一种对键计数的映射。更新现有的键，计数随之增加。可用于统计可哈希对象的实例数量，或者作为多重集使用。

#### shelve.Shelf

标准库中的shelve模块持久存储字符串键与Python对象之间的映射。

shelve.Shelf时abc.MutableMapping的子类，提供了我们预期的映射类型的基本方法。

shelve.SHelf还提供了一些其他I/O管理方法，例如sync和close。
