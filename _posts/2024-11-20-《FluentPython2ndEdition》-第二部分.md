---
layout: post
title: 《FluentPython2ndEdition》-第二部分
category: Read Notes
tags: [FluentPython2ndEdition, Pythonic]
comments: true
---

## 第七章 函数是一等对象

在Python中，函数是一等对象。编程语言研究人员把“一等对象”定义为满足以下条件的程序实体：●在运行时创建；●能赋值给变量或数据结构中的元素；●能作为参数传给函数；●能作为函数的返回结果。

### 把函数视为对象

### 高阶函数

接受函数为参数或者把函数作为结果返回的函数是高阶函数（higher-order-function）。map和内置函数sorted也是。

~~~python
    fruits = ['strawberries', 'limes', 'tomatoes']
    sorted(fruits, key=len)
~~~

### 匿名函数

lambda关键字使用Python表达式创建匿名函数。

除了作为参数传给高阶函数，Python很少使用匿名函数。由于句法上的限制，非平凡的lambda表达式要么难以阅读，要么无法写出。

如果使用lambda表达式导致一段代码难以理解，Fredrik Lundh建议像下面这样重构。
    01 编写注释，说明lambda表达式的作用。
    02 研究一会儿注释，找出一个名称来概括注释。
    03 把lambda表达式转换成def语句，使用那个名称来定义函数。
    04 删除注释。

### 9种可调用对象

除了函数，调用运算符(())还可以应用到其他对象上。数据模型文档列出了自Python 3.9起可用的9种可调用对象。
    定义的函数
    函数
    内置方法
    方法
    类
    类的实例
    生成器函数
    原生协程函数
    异步生成器函数

Python中有各种各样的可调用类型，因此判断对象能否调用，最安全的方法是使用内置函数callable()。

### 用户定义的可调用类型

实现__call__方法是创建类似函数的对象的简便方式，此时必须在内部维护一个状态，让它在多次调用之间存续，例如BingoCage中的剩余元素。__call__的另一个用处是实现装饰器。装饰器必须可调用，而且有时要在多次调用之间“记住”某些事[例如备忘(memoization)，即缓存消耗大的计算结果，供后面使用]，或者把复杂的操作分成几个方法实现。

在函数式编程中，创建保有内部状态的函数要使用闭包(closure)。

### 从位置参数到仅限关键参数

仅限关键字参数是Python3新增的功能。定义函数时，如果想只能通过关键字指定他，就要把他们放到前面有*的参数后面。如果不想支持数量不定的位置参数，但是想支持仅限关键字参数，则可以在签名中放一个*。

如果想定义只接受位置参数的函数，则可以在参数列表中使用/。

### 支持函数式编程的包

operator模块
    operator模块为多个运算符提供了对应的函数，无需再动手编写lambda a,b : a*b这样的匿名函数。

使用functools.partial冻结参数
    它可以根据提供的可调用对象产生一个新可调用对象，为原可调用对象的某些参数绑定预定的值。使用这个函数可以把接受一个或多个参数的函数改造成需要更少参数的回调API。

### 7.9 本章小结

本章的目标是探讨Python函数的一等本性。这意味着，可以把函数赋值给变量、传给其他函数、存储在数据结构中，以及访问函数的属性，供框架和一些工具使用。

## 第八章 函数中的类型提示

还应该强调的是，Python 仍是一门动态类型语言，作者并不意图强制使用类型提示，这只是一种约定。——Guido van Rossum、Jukka Lehtosalo和Łukasz Langa     “PEP 484—Type Hints”

### 关于渐进式类型

### 渐进式类型实践

类型检查工具Mypy最初也是一门语言，是Python的一种方言，有自己的解释器，支持渐进式类型。后经Guido van Rossum的劝说，Mypy的创建者Jukka Lehtosalo把它改造成了一个检查Python代码注解的工具。

类型提示在所有层面上均是可选的，一整个包都可以没有类型提示，即便有类型提示，导入模块时也可以让类型检查工具保持静默，另外还可以通过特殊的注释让类型检查工具忽略代码中指定的行。

100%的类型提示覆盖率太过激进，只是一味追求指标，不现实，也有碍团队充分利用Python的强大功能和灵活性。应该坦然接受没有类型提示的代码，防止注解扰乱API，增加实现难度。

编写类型提示时建议遵守以下代码风格。
    ●参数名称和:之间不留空格，:后加一个空格。
    ●参数默认值前面的=两侧加空格
    使用flake8和blue检查代码风格
        不要天真，你记不住这些规则。flake8会报告代码风格等问题，blue则会根据代码格式化工具black内置的（大多数）规则重写源码。
        blue的作者之一Barry Warsaw也是PEP 8的共同起草人，自1994年起一直是Python核心开发者，从2019年至今（2021年7月）还是Python指导委员会(Steering Council)的一员。默认使用单引号是有坚强后盾的。

使用None表示默认值

### 类型由受支持的操作定义

在渐进式类型系统中，以下两种对类型的解读相互影响着彼此。

鸭子类型
    该类型是Smalltalk（面向对象语言的先驱）以及Python、JavaScript和Ruby采用的解读视角。对象有类型，但是变量（包括参数）没有类型。在实践中，为对象声明的类型无关紧要，重要的是对象具体支持什么操作。如果能调用birdie.quack()，那么在当前上下文中birdie就是鸭子。根据定义，只有在运行时尝试操作对象时，才会施行鸭子类型相关的检查。这比名义类型(nominal typing)更灵活，但代价是运行时潜在的错误更多。

名义类型
    该类型是C++、Java和C#采用的解读视角，带注解的Python支持这种类型。对象和变量都有类型。但是，对象只存在于运行时，类型检查工具只关心使用类型提示注解变量（包括参数）的源码。如果Duck是Bird的子类，那么就可以把Duck实例赋值给注解为birdie: Bird的参数。可是在函数主体中，类型检查工具认为birdie.quack()调用是非法的，因为birdie名义上是Bird对象，而该类没有提供.quack()方法。在运行时，实参是不是Duck实例并不重要，因为名义类型会在静态检查阶段检查。类型检查工具不运行程序的任何部分，只读取源码。名义类型比鸭子类型更严格，优点是能在构建流水线中，甚至是在IDE中输入代码的过程中更早地捕获一些bug。

### 注解中可用的类型

本节涵盖了可用于注解的所有主要类型：

●typing.Any；
    Any是一种魔法类型，位于类型层次结构的顶部和底部。Any既是最一般的类型（使用n: Any注解的参数可接受任何类型的值），也是最特定的类型（支持所有可能的操作）。至少，在类型检查工具看来是这样。当然，没有任何一种类型可以支持所有可能的操作，因此使用Any不利于类型检查工具完成核心任务，即检测潜在的非法操作，防止运行时异常导致程序崩溃。
    在渐进式类型系统中还有一种关系：相容(consistent-with)。
    满足子类型关系必定是相容的，不过对Any还有特殊的规定。相容规则如下。
        01 对T1及其子类型T2，T2与T1相容（里氏替换）。
        02 任何类型都与Any相容：声明为Any类型的参数接受任何类型的对象。
        03 Any与任何类型都相容：始终可以把Any类型的对象传给预期其他类型的参数。

●简单的类型和类；
    像int、float、str和bytes这样的简单的类型可以直接在类型提示中使用。标准库、外部包中的具体类，以及用户定义的具体类（例如FrenchDeck、Vector2d和Duck），也可以在类型提示中使用。
    PEP 484声称，int与float相容，float与complex相容。从实用角度来看，这是合理的：int实现了float的所有操作，而且int还额外实现了&、|、<<等按位运算操作。因此，int也与complex相容。对于i = 3，i.real是3，i.imag是0。

●typing.Optional和typing.Union；
    Optional[str]结构其实是Union[str, None]的简写形式，表示plural的类型可以是str或None。

●泛化容器，包括元组和映射；
    如果想注解带有多个字段的元组，或者代码中多次用到的特定类型的元组，强烈建议使用typing.NamedTuple。
    如果想注解长度不定、用作不可变列表的元组，则只能指定一个类型，后跟逗号和...
●抽象基类；
    理想情况下，函数的参数应接受那些抽象类型（或Python3.9之前的版本中typing模块中对应的类型）​，而不是具体类型。这样对调用方来说更加灵活。
    因此，一般来说在参数的类型提示中最好使用abc.Mapping或abc.MutableMapping，不要使用dict（也不要在遗留代码中使用typing.Dict）​。
    在typing.List的文档中有这样一段话：泛化版list。可用于注解返回值类型。如果想注解参数，推荐使用抽象容器类型，例如Sequence或Iterable。
●泛化可迭代对象；
    typing.List文档推荐使用Sequence和Iterable注解函数的参数。
    与Sequence一样，Iterable最适合注解参数的类型。用来注解返回值类型的话则太过含糊。函数的返回值类型应该具体、明确。
●参数化泛型和TypeVar；
    参数化泛型是一种泛型，写作list[T]​，其中T是类型变量，每次使用时会绑定具体的类型。这样可在结果的类型中使用参数的类型。
    为什么需要TypeVar？
        PEP 484的作者希望借助typing模块引入类型提示，不改动语言的其他部分。通过精巧的元编程技术，让类支持[​]运算符（例如Sequence[T]​）不成问题。但是，方括号内的T变量必须在某处定义，否则要大范围改动Python解释器才能让泛型支持特殊的[​]表示法。鉴于此，我们增加了typing.TypeVar构造函数，把变量名称引入当前命名空间。
    受限的TypeVar
        TypeVar还接受一些位置参数，以对类型参数施加限制。
    有界的TypeVar
        使用TypeVar的另一个可选参数，即关键字参数bound。这个参数会为可接受的类型设定一个上边界。
        受限的类型变量会把类型设为TypeVar声明中列出的某个类型；
        有界的类型变量会把类型设为根据表达式推导出的类型，但前提是推导的类型与TypeVar的bound=关键字参数声明的边界相容。
    预定义的类型变量AnyStr
        typing模块提供了一个预定义的类型变量，名为AnyStr。这个类型变量的定义如下所示。
        AnyStr = TypeVar('AnyStr', str, bytes)
        很多接受bytes或str的函数会使用AnyStr，返回值也是二者之一。
●typing.Protocols——静态鸭子类型的关键；
    在Python中，协议通过typing.Protocol的子类定义。然而，实现协议的类不会与定义协议的类建立任何关系，不继承，也不用注册。类型检查工具负责查找可用的协议类型，施行用法检查。
●typing.Callable；
    collections.abc模块提供的Callable类型（尚未使用Python3.9的用户在typing模块中寻找）用于注解回调参数或高阶函数返回的可调用对象。
●typing.NoReturn。
    这个特殊类型仅用于注解绝不返回的函数的返回值类型。这类函数通常会抛出异常。标准库中有很多这样的函数。

### 注解仅限位置参数和变长参数

### 类型不完美，测试须全面

大型企业基准代码的维护人员反映，静态类型检查工具能发现很多bug，而且这个阶段发现的bug比上线运行之后发现的bug修复成本更低。然而，有必要指出的是，早在引入静态类型之前，自动化测试就已经是行业标准做法，我熟知的公司均已广泛采用。

建议把静态类型检查工具纳入现代CI流水线，与测试运行程序、lint程序等结合在一起使用。CI流水线的目的是减少软件故障，自动化测试可以捕获许多超出类型提示能力范围的bug。Python写出的代码都能使用Python测试，有没有类型提示无关紧要。

### 本章小结

类型提示是一个复杂的话题，还在不断发展中。幸运的是，这是可选功能，因此Python广泛的用户群体不受影响。请不要听信类型布道者的话，认为所有Python代码都需要类型提示。Python类型提示由荣誉的仁慈“独裁者”全力推动，为表感激，本章开头和结尾都引用了他的话。

我不希望在道德上有义务为一个Python版本一直添加类型提示。我坚信，类型提示有存在的必要，然而很多时候得不偿失。用与不用由你自己选择，这多好。[插图]——Guido van Rossum

## 第九章 装饰器和闭包

### 装饰器基础知识

装饰器是一种可调用的对象，其参数是另一个函数（被装饰的函数）。

装饰器可能会对被装饰的函数做一些处理，然后返回函数，或者把函数替换成另一个函数或可调用对象。

严格来说，装饰器只是语法糖，装饰器可以像常规的可调用函数一样调用，传入另一个函数。在做元编程（在运行时改变程序的行为）的时候，这样做尤其方便。

装饰器的三个基本性质
    装饰器是一个函数或其他可调用对象。
    装饰器可以把被装饰的函数替换成别的函数。
    装饰器在加载模块时立即执行。

### Python何时执行装饰器

装饰器的一个关键性质是，它们在被装饰的函数定义之后立即运行。这通常是在**导入时**（例如，Python加载模块时）。

### 注册装饰器

### 变量作用域规则

### 闭包

### nonlocal声明

### 实现一个简单的装饰器

### 标准库中的装饰器

### 参数化装饰器

### 9.11本章小结

## 第十章 使用一等函数实现设计模式
